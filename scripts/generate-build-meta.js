/*
 * Copyright (C) 2025 The MegaMek Team. All Rights Reserved.
 *
 * This file is part of MekBay.
 *
 * MekBay is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License (GPL),
 * version 3 or (at your option) any later version,
 * as published by the Free Software Foundation.
 *
 * MekBay is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * A copy of the GPL should have been included with this project;
 * if not, see <https://www.gnu.org/licenses/>.
 *
 * NOTICE: The MegaMek organization is a non-profit group of volunteers
 * creating free software for the BattleTech community.
 *
 * MechWarrior, BattleMech, `Mech and AeroTech are registered trademarks
 * of The Topps Company, Inc. All Rights Reserved.
 *
 * Catalyst Game Labs and the Catalyst Game Labs logo are trademarks of
 * InMediaRes Productions, LLC.
 *
 * MechWarrior Copyright Microsoft Corporation. MegaMek was created under
 * Microsoft's "Game Content Usage Rules"
 * <https://www.xbox.com/en-US/developers/rules> and it is not endorsed by or
 * affiliated with Microsoft.
 */

const fs = require('fs');
const path = require('path');
const child = require('child_process');

const root = path.resolve(__dirname, '..'); // app/ folder
const versionFile = path.join(root, 'src', 'app', 'version.constant.ts');
const buildMetaFile = path.join(root, 'src', 'app', 'build-meta.ts');

function readVersion() {
  const content = fs.readFileSync(versionFile, 'utf8');
  const m = content.match(/export\s+const\s+APP_VERSION\s*=\s*['"]([^'"]+)['"]/);
  return m ? m[1] : '0.0';
}

function git(cmd) {
  try {
    return child.execSync(cmd, { cwd: root, encoding: 'utf8' }).trim();
  } catch {
    return null;
  }
}

function detectBranch() {
  // Prefer GitHub Actions ref if available
  const ghRef = process.env.GITHUB_REF;
  if (ghRef) {
    // refs/heads/main -> main
    const m = ghRef.match(/^refs\/heads\/(.+)$/);
    if (m) return m[1];
    return ghRef;
  }

  // Fallback to git
  const branch = git('git rev-parse --abbrev-ref HEAD');
  return branch || 'unknown';
}

function writeBuildMeta(version, commitNumber, commitHash, branch, timestamp) {
  const versionString = `${version}.${commitNumber} (${branch}/${commitHash}) ${timestamp}`;
  const content = `// Auto-generated by scripts/generate-build-meta.js - do not edit
export const APP_VERSION = '${version}';
export const BUILD_COMMIT_NUMBER = ${commitNumber};
export const BUILD_COMMIT_HASH = '${commitHash}';
export const BUILD_BRANCH: string = '${branch}';
export const BUILD_TIMESTAMP = '${timestamp}';
export const APP_VERSION_STRING = '${versionString}';
`;
  fs.writeFileSync(buildMetaFile, content, 'utf8');
  return versionString;
}

(function main() {
  try {
    const version = readVersion();

    // commit count (number of commits reachable from HEAD)
    // TODO: reimplement it with an API call to GitHub so we don't have to use depth: 0 in checkout
    const commitNumber = parseInt(git('git rev-list --count HEAD') || '0', 10);

    // short commit hash
    const commitHash = git('git rev-parse --short HEAD') || 'unknown';
    const branch = detectBranch();

    const timestamp = new Date().toISOString();

    const generated = writeBuildMeta(version, commitNumber || 0, commitHash, branch, timestamp);
    console.log('Build meta generated:', generated);
  } catch (err) {
    console.error('Failed to generate build meta:', err);
    process.exitCode = 1;
  }
})();